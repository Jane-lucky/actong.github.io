并发：同一时间内可以执行多个任务——同时处理许多个任务。也就是将任务在不同的时间点交给处理器进行，微观来看是不会同时进行的

## Goroutine

协程：一个线程可以拥有多个协程

**优势**是轻量级，可以轻松创建上万个而不会导致系统资源衰竭。

属于抢占任务处理，和现有的多线程和多进程的处理十分类似

### 创建协程【demo1】
在函数或者方法面前加上关键字go，将同时进行一个新的Goroutine

会出现两种结果，那是因为协程运行中顺序不可控，如果在main完成之前进行，则均会打印，但如果在main的goroutine完成之后，完成，这就不会打印
```go
func Hello() {
	fmt.Println("Hello function")
}
func main() {
	go Hello()
	fmt.Println("main function")
}
```

### 启动多个协程

## channel
go的通道，协程之间的通信机制。

一个channel代表一个通信管道，可以让一个协程通过它给另一个协程发送数据；

传统的线程之间可以通过共享内存的方式进行数据交互，不同线程共享内存的同步问题需要使用锁来解决，性能会较低。Go语言主张通过**数据**传递来实现共享内存。

### 接受数据【demo3】
发送数据:`channel 变量 <- 值`

如果接受方一直没有接受，将会处于持续阻塞

接受数据：`data:=<-ch`

循环获取channel的数据时，可以采用判断通道是否关闭来结束通道，也可以通过for...range的方式，该方式会自主判断通道是否关闭

### 阻塞【demo4】
当数据被发送到channel的时候会发生阻塞，知道存在其他的Goroutine从该通道获取数据；

可以帮助有效的通信，而不需要使用其他语言中的显式锁或条件变量